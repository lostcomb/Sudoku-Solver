
==================== FINAL INTERFACE ====================
2017-06-24 23:02:39.8460939 UTC

interface main@main:Sudoku.Entry 8002
  interface hash: ea6ceb38df2f7ac2adf7c9b828c1c5be
  ABI hash: 11cbc9d65f681efba5157b72ef244a0f
  export-list hash: fb6ea1eab072e0d4518f55a8e342bb23
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: f9aeb0478de38b613a0029d5902709c6
  sig of: Nothing
  used TH splices: False
  where
exports:
  Sudoku.Entry.isEmpty
  Sudoku.Entry.isFull
  Sudoku.Entry.Entry{Sudoku.Entry.Empty Sudoku.Entry.Full}
module dependencies:
package dependencies: base-4.9.1.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:GHC.Enum 3beb5abd88e2173130728ffba8194381
import  -/  base-4.9.1.0:GHC.Num 38b8aac8807c096c7f3ca3c1eff02939
import  -/  base-4.9.1.0:GHC.Real b88ae4a48c079652623073a5bbf5c9b0
import  -/  base-4.9.1.0:GHC.Show eca5834daba3b6a2bbbe64ab52056707
import  -/  base-4.9.1.0:Prelude 74b3e204395920329f6de9d97206abe9
import  -/  ghc-prim-0.5.0.0:GHC.Classes 16d48e012d23eaef9bca91ccdd572c02
6089eb51599d3a84243e1c09c3c0188b
  $fEnumEntry :: GHC.Enum.Enum Sudoku.Entry.Entry
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Sudoku.Entry.Entry
                  Sudoku.Entry.$fEnumEntry_$csucc
                  Sudoku.Entry.$fEnumEntry_$cpred
                  Sudoku.Entry.$fEnumEntry_$ctoEnum
                  Sudoku.Entry.$fEnumEntry_$cfromEnum
                  Sudoku.Entry.$fEnumEntry_$cenumFrom
                  Sudoku.Entry.$fEnumEntry_$cenumFromThen
                  Sudoku.Entry.$fEnumEntry_$cenumFromTo
                  Sudoku.Entry.$fEnumEntry_$cenumFromThenTo -}
6089eb51599d3a84243e1c09c3c0188b
  $fEnumEntry1 :: [Sudoku.Entry.Entry]
  {- Unfolding: (Sudoku.Entry.$fEnumEntry_go1 0#) -}
36a4ea653cf3f8376b14aaba96f90d64
  $fEnumEntry2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
6089eb51599d3a84243e1c09c3c0188b
  $fEnumEntry3 :: Sudoku.Entry.Entry
  {- HasNoCafRefs,
     Unfolding: (Sudoku.Entry.Full Sudoku.Entry.$fEnumEntry4) -}
f2a0526a35365a0bc139dba0079b6562
  $fEnumEntry4 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# -1#) -}
6089eb51599d3a84243e1c09c3c0188b
  $fEnumEntry5 :: Sudoku.Entry.Entry
  {- HasNoCafRefs,
     Unfolding: (Sudoku.Entry.Full Sudoku.Entry.$fEnumEntry6) -}
87e313e0a7c98ae0d1b6a575e6395f6c
  $fEnumEntry6 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 1#) -}
6089eb51599d3a84243e1c09c3c0188b
  $fEnumEntry_$cenumFrom ::
    Sudoku.Entry.Entry -> [Sudoku.Entry.Entry]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: Sudoku.Entry.Entry) ->
                 case x of wild {
                   Sudoku.Entry.Full x1
                   -> case x1 of wild1 { GHC.Types.I# x2 ->
                      Sudoku.Entry.$fEnumEntry_go2 x2 }
                   Sudoku.Entry.Empty -> Sudoku.Entry.$fEnumEntry1 }) -}
6089eb51599d3a84243e1c09c3c0188b
  $fEnumEntry_$cenumFromThen ::
    Sudoku.Entry.Entry -> Sudoku.Entry.Entry -> [Sudoku.Entry.Entry]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Sudoku.Entry.Entry)
                   (y :: Sudoku.Entry.Entry) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Sudoku.Entry.Entry]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                     case y of wild {
                       Sudoku.Entry.Full x2
                       -> case x2 of wild1 { GHC.Types.I# x3 ->
                          GHC.Base.map
                            @ GHC.Types.Int
                            @ Sudoku.Entry.Entry
                            Sudoku.Entry.$fEnumEntry_$ctoEnum
                            (GHC.Enum.efdInt x1 x3) }
                       Sudoku.Entry.Empty
                       -> GHC.Base.map
                            @ GHC.Types.Int
                            @ Sudoku.Entry.Entry
                            Sudoku.Entry.$fEnumEntry_$ctoEnum
                            (GHC.Enum.efdInt x1 0#) }
                 } in
                 case x of wild {
                   Sudoku.Entry.Full x1
                   -> case x1 of wild1 { GHC.Types.I# x2 -> $j x2 }
                   Sudoku.Entry.Empty -> $j 0# }) -}
6089eb51599d3a84243e1c09c3c0188b
  $fEnumEntry_$cenumFromThenTo ::
    Sudoku.Entry.Entry
    -> Sudoku.Entry.Entry -> Sudoku.Entry.Entry -> [Sudoku.Entry.Entry]
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: (\ (x1 :: Sudoku.Entry.Entry)
                   (x2 :: Sudoku.Entry.Entry)
                   (y :: Sudoku.Entry.Entry) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Sudoku.Entry.Entry]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x4 :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Sudoku.Entry.Entry]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (x5 :: GHC.Prim.Int#)[OneShot] ->
                         case y of wild {
                           Sudoku.Entry.Full x
                           -> case x of wild2 { GHC.Types.I# y1 ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Sudoku.Entry.Entry]
                                     Sudoku.Entry.$fEnumEntry_c
                                     (GHC.Types.[] @ Sudoku.Entry.Entry)
                                     x4
                                     x5
                                     y1
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Sudoku.Entry.Entry]
                                     Sudoku.Entry.$fEnumEntry_c
                                     (GHC.Types.[] @ Sudoku.Entry.Entry)
                                     x4
                                     x5
                                     y1 } }
                           Sudoku.Entry.Empty
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.>=# x5 x4) of wild1 {
                                GHC.Types.False
                                -> GHC.Enum.efdtIntDnFB
                                     @ [Sudoku.Entry.Entry]
                                     Sudoku.Entry.$fEnumEntry_c
                                     (GHC.Types.[] @ Sudoku.Entry.Entry)
                                     x4
                                     x5
                                     0#
                                GHC.Types.True
                                -> GHC.Enum.efdtIntUpFB
                                     @ [Sudoku.Entry.Entry]
                                     Sudoku.Entry.$fEnumEntry_c
                                     (GHC.Types.[] @ Sudoku.Entry.Entry)
                                     x4
                                     x5
                                     0# } }
                     } in
                     case x2 of wild {
                       Sudoku.Entry.Full x
                       -> case x of wild1 { GHC.Types.I# x5 -> $j1 x5 }
                       Sudoku.Entry.Empty -> $j1 0# }
                 } in
                 case x1 of wild {
                   Sudoku.Entry.Full x -> case x of wild1 { GHC.Types.I# x4 -> $j x4 }
                   Sudoku.Entry.Empty -> $j 0# }) -}
6089eb51599d3a84243e1c09c3c0188b
  $fEnumEntry_$cenumFromTo ::
    Sudoku.Entry.Entry -> Sudoku.Entry.Entry -> [Sudoku.Entry.Entry]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Sudoku.Entry.Entry)
                   (y :: Sudoku.Entry.Entry) ->
                 let {
                   $j :: GHC.Prim.Int# -> [Sudoku.Entry.Entry]
                     {- Arity: 1, Strictness: <S,U> -}
                   = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                     case y of wild {
                       Sudoku.Entry.Full x2
                       -> case x2 of wild1 { GHC.Types.I# y1 ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 y1) of wild2 {
                            GHC.Types.False
                            -> letrec {
                                 go3 :: GHC.Prim.Int# -> [Sudoku.Entry.Entry]
                                   {- Arity: 1, Strictness: <L,U> -}
                                 = \ (x3 :: GHC.Prim.Int#) ->
                                   GHC.Types.:
                                     @ Sudoku.Entry.Entry
                                     (case x3 of ds {
                                        DEFAULT -> Sudoku.Entry.Full (GHC.Types.I# ds)
                                        0# -> Sudoku.Entry.Empty })
                                     (case GHC.Prim.tagToEnum#
                                             @ GHC.Types.Bool
                                             (GHC.Prim.==# x3 y1) of wild3 {
                                        GHC.Types.False -> go3 (GHC.Prim.+# x3 1#)
                                        GHC.Types.True -> GHC.Types.[] @ Sudoku.Entry.Entry })
                               } in
                               go3 x1
                            GHC.Types.True -> GHC.Types.[] @ Sudoku.Entry.Entry } }
                       Sudoku.Entry.Empty
                       -> case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.># x1 0#) of wild1 {
                            GHC.Types.False -> Sudoku.Entry.$fEnumEntry_go x1
                            GHC.Types.True -> GHC.Types.[] @ Sudoku.Entry.Entry } }
                 } in
                 case x of wild {
                   Sudoku.Entry.Full x1
                   -> case x1 of wild1 { GHC.Types.I# x2 -> $j x2 }
                   Sudoku.Entry.Empty -> $j 0# }) -}
6089eb51599d3a84243e1c09c3c0188b
  $fEnumEntry_$cfromEnum :: Sudoku.Entry.Entry -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Sudoku.Entry.Entry) ->
                 case ds of wild {
                   Sudoku.Entry.Full x -> x
                   Sudoku.Entry.Empty -> Sudoku.Entry.$fEnumEntry2 }) -}
6089eb51599d3a84243e1c09c3c0188b
  $fEnumEntry_$cpred :: Sudoku.Entry.Entry -> Sudoku.Entry.Entry
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (eta :: Sudoku.Entry.Entry) ->
                 case eta of wild {
                   Sudoku.Entry.Full x
                   -> case x of wild1 { GHC.Types.I# x1 ->
                      case GHC.Prim.-# x1 1# of ds {
                        DEFAULT -> Sudoku.Entry.Full (GHC.Types.I# ds)
                        0# -> Sudoku.Entry.Empty } }
                   Sudoku.Entry.Empty -> Sudoku.Entry.$fEnumEntry3 }) -}
6089eb51599d3a84243e1c09c3c0188b
  $fEnumEntry_$csucc :: Sudoku.Entry.Entry -> Sudoku.Entry.Entry
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (eta :: Sudoku.Entry.Entry) ->
                 case eta of wild {
                   Sudoku.Entry.Full x
                   -> case x of wild1 { GHC.Types.I# x1 ->
                      case GHC.Prim.+# x1 1# of ds {
                        DEFAULT -> Sudoku.Entry.Full (GHC.Types.I# ds)
                        0# -> Sudoku.Entry.Empty } }
                   Sudoku.Entry.Empty -> Sudoku.Entry.$fEnumEntry5 }) -}
6089eb51599d3a84243e1c09c3c0188b
  $fEnumEntry_$ctoEnum :: GHC.Types.Int -> Sudoku.Entry.Entry
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Types.Int) ->
                 case ds of wild { GHC.Types.I# ds1 ->
                 case ds1 of ds2 {
                   DEFAULT -> Sudoku.Entry.Full wild 0# -> Sudoku.Entry.Empty } }) -}
6089eb51599d3a84243e1c09c3c0188b
  $fEnumEntry_c ::
    GHC.Types.Int -> [Sudoku.Entry.Entry] -> [Sudoku.Entry.Entry]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (ys :: [Sudoku.Entry.Entry]) ->
                 GHC.Types.:
                   @ Sudoku.Entry.Entry
                   (Sudoku.Entry.$fEnumEntry_$ctoEnum x)
                   ys) -}
6089eb51599d3a84243e1c09c3c0188b
  $fEnumEntry_go :: GHC.Prim.Int# -> [Sudoku.Entry.Entry]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
6089eb51599d3a84243e1c09c3c0188b
  $fEnumEntry_go1 :: GHC.Prim.Int# -> [Sudoku.Entry.Entry]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
6089eb51599d3a84243e1c09c3c0188b
  $fEnumEntry_go2 :: GHC.Prim.Int# -> [Sudoku.Entry.Entry]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U> -}
6089eb51599d3a84243e1c09c3c0188b
  $fEqEntry :: GHC.Classes.Eq Sudoku.Entry.Entry
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Sudoku.Entry.Entry
                  Sudoku.Entry.$fEqEntry_$c==
                  Sudoku.Entry.$fEqEntry_$c/= -}
6089eb51599d3a84243e1c09c3c0188b
  $fEqEntry_$c/= ::
    Sudoku.Entry.Entry -> Sudoku.Entry.Entry -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Sudoku.Entry.Entry)
                   (b :: Sudoku.Entry.Entry) ->
                 case a of wild {
                   Sudoku.Entry.Full a1
                   -> case b of wild1 {
                        Sudoku.Entry.Full b1
                        -> case a1 of wild2 { GHC.Types.I# x ->
                           case b1 of wild3 { GHC.Types.I# y ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.==# x y) of wild4 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False } } }
                        Sudoku.Entry.Empty -> GHC.Types.True }
                   Sudoku.Entry.Empty
                   -> case b of wild1 {
                        Sudoku.Entry.Full ipv -> GHC.Types.True
                        Sudoku.Entry.Empty -> GHC.Types.False } }) -}
6089eb51599d3a84243e1c09c3c0188b
  $fEqEntry_$c== ::
    Sudoku.Entry.Entry -> Sudoku.Entry.Entry -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Sudoku.Entry.Entry) (ds1 :: Sudoku.Entry.Entry) ->
                 case ds of wild {
                   Sudoku.Entry.Full a1
                   -> case ds1 of wild1 {
                        Sudoku.Entry.Full b1 -> GHC.Classes.eqInt a1 b1
                        Sudoku.Entry.Empty -> GHC.Types.False }
                   Sudoku.Entry.Empty
                   -> case ds1 of wild1 {
                        Sudoku.Entry.Full ipv -> GHC.Types.False
                        Sudoku.Entry.Empty -> GHC.Types.True } }) -}
6089eb51599d3a84243e1c09c3c0188b
  $fNumEntry :: GHC.Num.Num Sudoku.Entry.Entry
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Sudoku.Entry.Entry
                  Sudoku.Entry.$fNumEntry_$c+
                  Sudoku.Entry.$fNumEntry_$c-
                  Sudoku.Entry.$fNumEntry_$c*
                  Sudoku.Entry.$fNumEntry_$cnegate
                  Sudoku.Entry.$fNumEntry_$cabs
                  Sudoku.Entry.$fNumEntry_$csignum
                  Sudoku.Entry.$fNumEntry_$cfromInteger -}
7d921955984ff3ddeecb82b8ed0bc056
  $fNumEntry1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
6089eb51599d3a84243e1c09c3c0188b
  $fNumEntry_$c* ::
    Sudoku.Entry.Entry -> Sudoku.Entry.Entry -> Sudoku.Entry.Entry
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Sudoku.Entry.Entry) (ds :: Sudoku.Entry.Entry) ->
                 case ds of wild {
                   Sudoku.Entry.Full ipv
                   -> case x of wild1 {
                        Sudoku.Entry.Full i
                        -> Sudoku.Entry.Full (GHC.Num.$fNumInt_$c* i ipv)
                        Sudoku.Entry.Empty -> Sudoku.Entry.Empty }
                   Sudoku.Entry.Empty -> Sudoku.Entry.Empty }) -}
6089eb51599d3a84243e1c09c3c0188b
  $fNumEntry_$c+ ::
    Sudoku.Entry.Entry -> Sudoku.Entry.Entry -> Sudoku.Entry.Entry
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Sudoku.Entry.Entry) (ds :: Sudoku.Entry.Entry) ->
                 case ds of wild {
                   Sudoku.Entry.Full ipv
                   -> case x of wild1 {
                        Sudoku.Entry.Full i
                        -> Sudoku.Entry.Full (GHC.Num.$fNumInt_$c+ i ipv)
                        Sudoku.Entry.Empty -> wild }
                   Sudoku.Entry.Empty -> x }) -}
6089eb51599d3a84243e1c09c3c0188b
  $fNumEntry_$c- ::
    Sudoku.Entry.Entry -> Sudoku.Entry.Entry -> Sudoku.Entry.Entry
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Sudoku.Entry.Entry) (y :: Sudoku.Entry.Entry) ->
                 Sudoku.Entry.$fNumEntry_$c+
                   x
                   (Sudoku.Entry.$fNumEntry_$cnegate y)) -}
6089eb51599d3a84243e1c09c3c0188b
  $fNumEntry_$cabs :: Sudoku.Entry.Entry -> Sudoku.Entry.Entry
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Sudoku.Entry.Entry) ->
                 case ds of wild {
                   Sudoku.Entry.Full x -> Sudoku.Entry.Full (GHC.Num.$fNumInt_$cabs x)
                   Sudoku.Entry.Empty -> Sudoku.Entry.Empty }) -}
6089eb51599d3a84243e1c09c3c0188b
  $fNumEntry_$cfromInteger ::
    GHC.Integer.Type.Integer -> Sudoku.Entry.Entry
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: (\ (ds :: GHC.Integer.Type.Integer) ->
                 case GHC.Integer.Type.eqInteger#
                        ds
                        Sudoku.Entry.$fNumEntry1 of wild { DEFAULT ->
                 case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild of wild1 {
                   GHC.Types.False
                   -> Sudoku.Entry.Full (GHC.Num.$fNumInt_$cfromInteger ds)
                   GHC.Types.True -> Sudoku.Entry.Empty } }) -}
6089eb51599d3a84243e1c09c3c0188b
  $fNumEntry_$cnegate :: Sudoku.Entry.Entry -> Sudoku.Entry.Entry
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Sudoku.Entry.Entry) ->
                 case ds of wild {
                   Sudoku.Entry.Full x
                   -> Sudoku.Entry.Full (GHC.Num.$fNumInt_$cnegate x)
                   Sudoku.Entry.Empty -> Sudoku.Entry.Empty }) -}
6089eb51599d3a84243e1c09c3c0188b
  $fNumEntry_$csignum :: Sudoku.Entry.Entry -> Sudoku.Entry.Entry
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Sudoku.Entry.Entry) ->
                 case ds of wild {
                   Sudoku.Entry.Full x
                   -> Sudoku.Entry.Full (GHC.Num.$fNumInt_$csignum x)
                   Sudoku.Entry.Empty -> Sudoku.Entry.Empty }) -}
6089eb51599d3a84243e1c09c3c0188b
  $fShowEntry :: GHC.Show.Show Sudoku.Entry.Entry
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Sudoku.Entry.Entry
                  Sudoku.Entry.$fShowEntry_$cshowsPrec
                  Sudoku.Entry.$fShowEntry_$cshow
                  Sudoku.Entry.$fShowEntry_$cshowList -}
e62d248eaf3f318bcaa266768ba2602a
  $fShowEntry1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "."#) -}
6089eb51599d3a84243e1c09c3c0188b
  $fShowEntry_$cshow :: Sudoku.Entry.Entry -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Sudoku.Entry.Entry) ->
                 case ds of wild {
                   Sudoku.Entry.Full i -> GHC.Show.$fShowInt_$cshow i
                   Sudoku.Entry.Empty -> Sudoku.Entry.$fShowEntry1 }) -}
6089eb51599d3a84243e1c09c3c0188b
  $fShowEntry_$cshowList :: [Sudoku.Entry.Entry] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Sudoku.Entry.Entry]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ Sudoku.Entry.Entry
                   (Sudoku.Entry.$fShowEntry_$cshowsPrec GHC.Show.shows22)
                   ls
                   s) -}
6089eb51599d3a84243e1c09c3c0188b
  $fShowEntry_$cshowsPrec ::
    GHC.Types.Int -> Sudoku.Entry.Entry -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Sudoku.Entry.Entry)
                   (w2 :: GHC.Base.String) ->
                 Sudoku.Entry.$w$cshowsPrec w1 w2) -}
37776510ba731fbab1b601664be51f66
  $tc'Empty :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10342457087548772798##
                   3764909509812985743##
                   Sudoku.Entry.$trModule
                   Sudoku.Entry.$tc'Empty1) -}
7775e6d79b0fd429d87a4d6d934ca7f1
  $tc'Empty1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Empty"#) -}
383843023eed400384716f027c4819c7
  $tc'Full :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8432819862131771355##
                   8930732325720600894##
                   Sudoku.Entry.$trModule
                   Sudoku.Entry.$tc'Full1) -}
bce2d29f513a086750004de0eda08861
  $tc'Full1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Full"#) -}
bd75bf90bbb51dd0306ff0f7f27494c2
  $tcEntry :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7768287382153594915##
                   11070211203527858699##
                   Sudoku.Entry.$trModule
                   Sudoku.Entry.$tcEntry1) -}
48a58cbe662cf6144a00e15ab043550e
  $tcEntry1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Entry"#) -}
96b0cfd6aac2535980507eb8d5abe2a2
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Sudoku.Entry.$trModule2
                   Sudoku.Entry.$trModule1) -}
8fd254625c0e902e8ff965bdc26acee5
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Sudoku.Entry"#) -}
7ca601b14762c898975723f3ea08b0ea
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
6089eb51599d3a84243e1c09c3c0188b
  $w$cshowsPrec ::
    Sudoku.Entry.Entry -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Sudoku.Entry.Entry) (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Sudoku.Entry.Full i
                   -> case i of ww2 { GHC.Types.I# ww3 ->
                      case GHC.Show.$wshowSignedInt
                             0#
                             ww3
                             (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                      GHC.Base.++
                        @ GHC.Types.Char
                        (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                        w1 } }
                   Sudoku.Entry.Empty
                   -> GHC.Base.++ @ GHC.Types.Char Sudoku.Entry.$fShowEntry1 w1 }) -}
6089eb51599d3a84243e1c09c3c0188b
  data Entry = Full GHC.Types.Int | Empty
e300e17572d4ee24d3d481fa66a3abcf
  isEmpty :: Sudoku.Entry.Entry -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Sudoku.Entry.Entry) ->
                 case ds of wild {
                   Sudoku.Entry.Full ipv -> GHC.Types.False
                   Sudoku.Entry.Empty -> GHC.Types.True }) -}
5734b1901f5c3a0fa4c29853eaba7d35
  isFull :: Sudoku.Entry.Entry -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Sudoku.Entry.Entry) ->
                 case ds of wild {
                   Sudoku.Entry.Full ds1 -> GHC.Types.True
                   Sudoku.Entry.Empty -> GHC.Types.False }) -}
instance [safe] GHC.Enum.Enum [Sudoku.Entry.Entry]
  = Sudoku.Entry.$fEnumEntry
instance [safe] GHC.Classes.Eq [Sudoku.Entry.Entry]
  = Sudoku.Entry.$fEqEntry
instance [safe] GHC.Num.Num [Sudoku.Entry.Entry]
  = Sudoku.Entry.$fNumEntry
instance [safe] GHC.Show.Show [Sudoku.Entry.Entry]
  = Sudoku.Entry.$fShowEntry
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

