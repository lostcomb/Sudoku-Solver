
==================== FINAL INTERFACE ====================
2017-06-13 14:53:42.1726816 UTC

interface main@main:Solver 8002
  interface hash: 2617c7a046f9f15f491cf1bb82703c03
  ABI hash: 0ce651329fe1a443112c250d2d27a374
  export-list hash: c7110509af20cfb465b8272db30634f0
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 9d5d0e5951e43ac5c54d51d3e1285ccf
  sig of: Nothing
  used TH splices: False
  where
exports:
  Solver.findSolution
  Solver.genFullLevel
  Solver.genMinLevel
  Solver.nextLevel
  Solver.solve
module dependencies: Sudoku
package dependencies: base-4.9.1.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:Data.Foldable 254e836c2d813d34e47feb29bb8d40ed
import  -/  base-4.9.1.0:Data.List 7349774f430841349c90dfd1144aea97
import  -/  base-4.9.1.0:Data.OldList c9282ee91951bdcbd918d2960562c007
import  -/  base-4.9.1.0:GHC.Base 4caea1123ecf4b46e27cbccd6d279377
import  -/  base-4.9.1.0:Prelude 74b3e204395920329f6de9d97206abe9
import  -/  ghc-prim-0.5.0.0:GHC.Classes 16d48e012d23eaef9bca91ccdd572c02
import  -/  Sudoku eb6464a3157ff8483f52438e3800ef99
  exports: 79fcaaf52c39012888be358e6a29850f
  Board bcf6e97b562b4d4344081794ebcbd5fa
  complete 751c57ac753421e0d2061ab96920d165
  emptyEntries 6610e489d365d7f7c4c1b35258ffa603
  updateEntry d5e13642e6156511b8d6de7d957fb6d1
  validEntries fda8e8d818a6dbc1d8b3cface03f51c9
fc34009f402ef05eda146bbf36a21bc2
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Solver.$trModule2
                   Solver.$trModule1) -}
7ef4fd75cf014e6e02299ae9ac4bbe99
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Solver"#) -}
887e34e6b22165b38689c5715091335f
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
3e08ad0ea82b445939cc5c1f1f648d37
  $wnextLevel :: GHC.Types.Int -> [Sudoku.Row] -> [[Sudoku.Board]]
  {- Arity: 2, Strictness: <L,U(U)><S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Types.Int) (ww1 :: [Sudoku.Row]) ->
                 let {
                   lvl2 :: Sudoku.Board = Sudoku.Board ww ww1
                 } in
                 GHC.Base.map
                   @ (GHC.Types.Int, GHC.Types.Int)
                   @ [Sudoku.Board]
                   (\ (ds :: (GHC.Types.Int, GHC.Types.Int)) ->
                    case ds of wild { (,) row col ->
                    case row of ww3 { GHC.Types.I# ww4 ->
                    case col of ww5 { GHC.Types.I# ww6 ->
                    let {
                      lvl3 :: GHC.Types.Bool
                      = GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# ww6 0#)
                    } in
                    let {
                      lvl4 :: GHC.Types.Bool
                      = GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# ww4 0#)
                    } in
                    let {
                      lvl5 :: Sudoku.Row = GHC.List.$w!! @ Sudoku.Row ww1 ww4
                    } in
                    GHC.Base.map
                      @ Sudoku.Entry
                      @ Sudoku.Board
                      (\ (w3 :: Sudoku.Entry) ->
                       case GHC.List.$wlenAcc @ [Sudoku.Entry] ww1 0# of ww2 { DEFAULT ->
                       case GHC.Prim.tagToEnum#
                              @ GHC.Types.Bool
                              (GHC.Prim.>=# ww4 ww2) of wild1 {
                         GHC.Types.False
                         -> case GHC.Prim.tagToEnum#
                                   @ GHC.Types.Bool
                                   (GHC.Prim.>=# ww6 ww2) of wild2 {
                              GHC.Types.False
                              -> case lvl4 of wild3 {
                                   GHC.Types.False
                                   -> case lvl3 of wild4 {
                                        GHC.Types.False
                                        -> Sudoku.Board
                                             ww
                                             (Sudoku.$wupdate
                                                @ [Sudoku.Entry]
                                                ww4
                                                (Sudoku.$wupdate @ Sudoku.Entry ww6 w3 lvl5)
                                                ww1)
                                        GHC.Types.True -> lvl2 }
                                   GHC.Types.True -> lvl2 }
                              GHC.Types.True -> lvl2 }
                         GHC.Types.True -> lvl2 } })
                      (Sudoku.$wvalidEntries ww ww1 ww4 ww6) } } })
                   (Sudoku.emptyEntries_coordinates
                      Sudoku.emptyEntries2
                      (GHC.Base.map
                         @ [Sudoku.Entry]
                         @ [GHC.Types.Int]
                         Sudoku.emptyEntries1
                         ww1))) -}
0533adc08dc9fe673174732ef0040b8b
  findSolution :: [Sudoku.Board] -> GHC.Base.Maybe Sudoku.Board
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
ed877f35e56704099147285ea13e41ed
  genFullLevel :: [Sudoku.Board] -> [Sudoku.Board]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: [Sudoku.Board]) -> Solver.genFullLevel_go x) -}
850fad605559694991b094b3baa09465
  genFullLevel_go :: [Sudoku.Board] -> [Sudoku.Board]
  {- Arity: 1, Strictness: <S,1*U> -}
226ff1a07b77f9ca2ae1ef20f8014827
  genMinLevel :: [Sudoku.Board] -> [Sudoku.Board]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (boards :: [Sudoku.Board]) ->
                 Solver.genMinLevel_go1 (Solver.genMinLevel_go boards)) -}
c9ed8f13d5ee35a5b8c819263bd3e294
  genMinLevel_go :: [Sudoku.Board] -> [[Sudoku.Board]]
  {- Arity: 1, Strictness: <S,1*U> -}
2ba796368a1fa066f24da8ec5aede23b
  genMinLevel_go1 :: [[Sudoku.Board]] -> [Sudoku.Board]
  {- Arity: 1, Strictness: <S,1*U> -}
178d9c03b67361fcd5a5281f0a62cd6c
  nextLevel :: Sudoku.Board -> [[Sudoku.Board]]
  {- Arity: 1, Strictness: <S(LS),1*U(U(U),U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Sudoku.Board) ->
                 case w of ww { Sudoku.Board ww1 ww2 ->
                 Solver.$wnextLevel ww1 ww2 }) -}
613e49282ea68e7d7bbcf952a89ddf06
  solve :: Sudoku.Board -> GHC.Base.Maybe Sudoku.Board
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (board :: Sudoku.Board) ->
                 Solver.solve_solve'
                   (GHC.Types.:
                      @ Sudoku.Board
                      board
                      (GHC.Types.[] @ Sudoku.Board))) -}
d32334586e1fef85559971f553eea2ca
  solve_solve' :: [Sudoku.Board] -> GHC.Base.Maybe Sudoku.Board
  {- Arity: 1, Strictness: <S,1*U> -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

