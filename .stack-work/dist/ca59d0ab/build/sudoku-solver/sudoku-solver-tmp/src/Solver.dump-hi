
==================== FINAL INTERFACE ====================
2017-06-23 15:22:29.0803222 UTC

interface main@main:Solver 8002
  interface hash: 31e226eeb18fc81d367c69a2f02eec8a
  ABI hash: 4e74f1f628ccd0f9dc63c25f85d43e1f
  export-list hash: e00029da8439596fa29a3c8250e4570c
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 9d5d0e5951e43ac5c54d51d3e1285ccf
  sig of: Nothing
  used TH splices: False
  where
exports:
  Solver.minimumLength
  Solver.nextLevel
  Solver.nextStepBF
  Solver.nextStepDF
  Solver.solution
  Solver.solve
module dependencies: Sudoku
package dependencies: base-4.9.1.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:Data.Foldable 254e836c2d813d34e47feb29bb8d40ed
import  -/  base-4.9.1.0:Data.List 7349774f430841349c90dfd1144aea97
import  -/  base-4.9.1.0:Data.OldList c9282ee91951bdcbd918d2960562c007
import  -/  base-4.9.1.0:GHC.Base 4caea1123ecf4b46e27cbccd6d279377
import  -/  base-4.9.1.0:Prelude 74b3e204395920329f6de9d97206abe9
import  -/  ghc-prim-0.5.0.0:GHC.Classes 16d48e012d23eaef9bca91ccdd572c02
import  -/  Sudoku cbdeed1130064e2ee058cf35e212c94d
  exports: bc4f6f0102caebd68ec88d40af7b5792
  Board 0c55e2eef340310bbd77e171b8476532
  complete 4da58fc5682b39af876c4cffcfc8d094
  emptyEntries 2ec0a305da793968682fc0ad78a405a2
  updateEntry 2cc45edfa5a8953c848741d518a7d440
  validEntries 83482474b833e92162d7928e30144bf6
fc34009f402ef05eda146bbf36a21bc2
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Solver.$trModule2
                   Solver.$trModule1) -}
7ef4fd75cf014e6e02299ae9ac4bbe99
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Solver"#) -}
887e34e6b22165b38689c5715091335f
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
e17171b5070e3b38a60cd69f29803ec8
  $wnextLevel ::
    GHC.Types.Int
    -> [Sudoku.Row] -> [Sudoku.Constraint] -> [[Sudoku.Board]]
  {- Arity: 3, Strictness: <L,U(U)><S,U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Types.Int)
                   (ww1 :: [Sudoku.Row])
                   (ww2 :: [Sudoku.Constraint]) ->
                 let {
                   lvl3 :: Sudoku.Board = Sudoku.Board ww ww1 ww2
                 } in
                 GHC.Base.map
                   @ (GHC.Types.Int, GHC.Types.Int)
                   @ [Sudoku.Board]
                   (\ (ds :: (GHC.Types.Int, GHC.Types.Int)) ->
                    case ds of wild { (,) row col ->
                    case row of ww4 { GHC.Types.I# ww5 ->
                    case col of ww6 { GHC.Types.I# ww7 ->
                    let {
                      lvl4 :: GHC.Types.Bool
                      = GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# ww7 0#)
                    } in
                    let {
                      lvl5 :: GHC.Types.Bool
                      = GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# ww5 0#)
                    } in
                    let {
                      lvl6 :: Sudoku.Row = GHC.List.$w!! @ Sudoku.Row ww1 ww5
                    } in
                    GHC.Base.map
                      @ Sudoku.Entry
                      @ Sudoku.Board
                      (\ (w3 :: Sudoku.Entry) ->
                       case GHC.List.$wlenAcc @ [Sudoku.Entry] ww1 0# of ww3 { DEFAULT ->
                       case GHC.Prim.tagToEnum#
                              @ GHC.Types.Bool
                              (GHC.Prim.>=# ww5 ww3) of wild1 {
                         GHC.Types.False
                         -> case GHC.Prim.tagToEnum#
                                   @ GHC.Types.Bool
                                   (GHC.Prim.>=# ww7 ww3) of wild2 {
                              GHC.Types.False
                              -> case lvl5 of wild3 {
                                   GHC.Types.False
                                   -> case lvl4 of wild4 {
                                        GHC.Types.False
                                        -> Sudoku.Board
                                             ww
                                             (Sudoku.$wupdate
                                                @ [Sudoku.Entry]
                                                ww5
                                                (Sudoku.$wupdate @ Sudoku.Entry ww7 w3 lvl6)
                                                ww1)
                                             ww2
                                        GHC.Types.True -> lvl3 }
                                   GHC.Types.True -> lvl3 }
                              GHC.Types.True -> lvl3 }
                         GHC.Types.True -> lvl3 } })
                      (Sudoku.$wvalidEntries ww ww1 ww5 ww7) } } })
                   (Sudoku.emptyEntries_coordinates
                      Sudoku.emptyEntries3
                      (GHC.Base.map
                         @ [Sudoku.Entry]
                         @ [GHC.Types.Int]
                         Sudoku.emptyEntries1
                         ww1))) -}
afb3f7eec37a392dc139f74acc597def
  minimumLength :: Data.Foldable.Foldable t => [t a] -> t a
  {- Arity: 2,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,C(U(U)),A,A,A,A,A)><S,1*U>,
     Unfolding: (\ @ (t :: * -> *)
                   @ a
                   ($dFoldable :: Data.Foldable.Foldable t)
                   (eta :: [t a]) ->
                 letrec {
                   go1 :: [t a] -> t a {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [t a]) ->
                     case ds of wild {
                       [] -> Solver.minimumLength2 @ t @ a
                       : x ds1
                       -> case ds1 of wild1 {
                            [] -> x
                            : ipv ipv1
                            -> case Data.Foldable.length
                                      @ t
                                      $dFoldable
                                      @ a
                                      x of wild2 { GHC.Types.I# x# ->
                               let {
                                 y :: t a = go1 wild1
                               } in
                               case Data.Foldable.length
                                      @ t
                                      $dFoldable
                                      @ a
                                      y of wild3 { GHC.Types.I# y# ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.<# x# y#) of wild4 {
                                 GHC.Types.False
                                 -> case GHC.Prim.tagToEnum#
                                           @ GHC.Types.Bool
                                           (GHC.Prim.==# x# y#) of wild5 {
                                      GHC.Types.False -> y GHC.Types.True -> x }
                                 GHC.Types.True -> x } } } } }
                 } in
                 go1 eta) -}
9b8f2c4bbf90416050f055f0e699a349
  minimumLength2 :: t a
  {- Strictness: x -}
4e182a832f78fb963acfc1679ffd3119
  nextLevel :: Sudoku.Board -> [[Sudoku.Board]]
  {- Arity: 1, Strictness: <S(LSL),1*U(U(U),U,U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Sudoku.Board) ->
                 case w of ww { Sudoku.Board ww1 ww2 ww3 ->
                 Solver.$wnextLevel ww1 ww2 ww3 }) -}
d55f7bd1acc437c2b6983957882ba99f
  nextStepBF :: [Sudoku.Board] -> [Sudoku.Board]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Sudoku.Board]) ->
                 case ds of wild {
                   [] -> Solver.nextStepBF1
                   : x xs
                   -> GHC.Base.++
                        @ Sudoku.Board
                        xs
                        (case x of ww { Sudoku.Board ww1 ww2 ww3 ->
                         Solver.nextStepBF_go (Solver.$wnextLevel ww1 ww2 ww3) }) }) -}
a45516dda6fd492feb9dc0bab5b05cb6
  nextStepBF1 :: [Sudoku.Board]
  {- Strictness: x -}
4efbd17570088d0b347424ce7585ee31
  nextStepBF_go :: [[Sudoku.Board]] -> [Sudoku.Board]
  {- Arity: 1, Strictness: <S,1*U> -}
394d749d5cce4a23524034fcbcc2ee2d
  nextStepDF :: [Sudoku.Board] -> [Sudoku.Board]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Sudoku.Board]) ->
                 case ds of wild {
                   [] -> Solver.nextStepDF1
                   : x xs
                   -> case x of ww { Sudoku.Board ww1 ww2 ww3 ->
                      GHC.Base.++
                        @ Sudoku.Board
                        (Solver.nextStepDF_go (Solver.$wnextLevel ww1 ww2 ww3))
                        xs } }) -}
bf7b3e74488b04e4cc72ce7a8d092241
  nextStepDF1 :: [Sudoku.Board]
  {- Strictness: x -}
30d92a059d2f54f527399d7e2e51637e
  nextStepDF_go :: [[Sudoku.Board]] -> [Sudoku.Board]
  {- Arity: 1, Strictness: <S,1*U> -}
45106777718da7869fcc0b031caa290b
  solution ::
    [Sudoku.Board] -> GHC.Base.Maybe (Sudoku.Board, [Sudoku.Board])
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Sudoku.Board]) ->
                 case ds of wild {
                   [] -> GHC.Base.Nothing @ (Sudoku.Board, [Sudoku.Board])
                   : x xs
                   -> case x of ww { Sudoku.Board ww1 ww2 ww3 ->
                      case (Sudoku.complete_go ww2)
                             `cast`
                           (Data.Monoid.N:All[0]) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.Nothing @ (Sudoku.Board, [Sudoku.Board])
                        GHC.Types.True
                        -> GHC.Base.Just
                             @ (Sudoku.Board, [Sudoku.Board])
                             (ww, xs) } } }) -}
73f852d91f4db7e433086881d81ca9df
  solve ::
    [Sudoku.Board] -> GHC.Base.Maybe (Sudoku.Board, [Sudoku.Board])
  {- Arity: 1, Strictness: <S,1*U> -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

