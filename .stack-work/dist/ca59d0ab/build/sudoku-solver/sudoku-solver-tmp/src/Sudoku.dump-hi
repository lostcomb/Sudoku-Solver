
==================== FINAL INTERFACE ====================
2017-06-25 16:49:44.5366895 UTC

interface main@main:Sudoku 8002
  interface hash: 277d554ac761640cba8f8efa688ea15a
  ABI hash: 72d20ccc67d28a0846d2e137bec617ad
  export-list hash: cadf130518dc07acda288b3e48d0c14b
  orphan hash: f86519ac810174db7c532518013c7aed
  flag hash: 9d5d0e5951e43ac5c54d51d3e1285ccf
  sig of: Nothing
  used TH splices: False
  where
exports:
  Sudoku.complete
  Sudoku.emptyEntries
  Sudoku.inConstraint
  Sudoku.intersectAll
  Sudoku.possibleValues
  Sudoku.validEntries
  Sudoku.Board.addConstraints
  Sudoku.Board.chunk
  Sudoku.Board.defaultConstraints
  Sudoku.Board.emptyBoard
  Sudoku.Board.fromList
  Sudoku.Board.updateEntry
  Sudoku.Entry.isEmpty
  Sudoku.Entry.isFull
  Sudoku.Board.Board{Sudoku.Board.Board boxSize cs mat noFull}
  Sudoku.Board.Constraint{Sudoku.Board.Box Sudoku.Board.Column Sudoku.Board.Row Sudoku.Board.Sum Sudoku.Board.Unique}
  Sudoku.Entry.Entry{Sudoku.Entry.Empty Sudoku.Entry.Full}
module dependencies: Sudoku.Board Sudoku.Entry
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.1.0
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1 loop-0.3.0@loop-0.3.0-4tGn4RSY02pFTwJ5L4CYRr
                      matrix-0.3.5.0@matrix-0.3.5.0-eFZR6K8Lax4OrNeuTQF4y
                      primitive-0.6.1.0@primitive-0.6.1.0-6AbSTw9JXz141LE5p6LGH
                      transformers-0.5.2.0@transformers-0.5.2.0
                      vector-0.11.0.0@vector-0.11.0.0-LMwQhhnXj8U3T5Bm1JFxG
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
         vector-0.11.0.0@vector-0.11.0.0-LMwQhhnXj8U3T5Bm1JFxG:Data.Vector.Fusion.Bundle
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         primitive-0.6.1.0@primitive-0.6.1.0-6AbSTw9JXz141LE5p6LGH:Control.Monad.Primitive
                         vector-0.11.0.0@vector-0.11.0.0-LMwQhhnXj8U3T5Bm1JFxG:Data.Vector
import  -/  base-4.9.1.0:Data.Foldable 254e836c2d813d34e47feb29bb8d40ed
import  -/  base-4.9.1.0:Data.List 7349774f430841349c90dfd1144aea97
import  -/  base-4.9.1.0:Data.OldList c9282ee91951bdcbd918d2960562c007
import  -/  base-4.9.1.0:GHC.Base 4caea1123ecf4b46e27cbccd6d279377
import  -/  base-4.9.1.0:GHC.Err 20faef8829fd13c027d0ee2213637534
import  -/  base-4.9.1.0:GHC.List d11eb227c1c6fbfd89bb781d72eaea0d
import  -/  base-4.9.1.0:GHC.Real b88ae4a48c079652623073a5bbf5c9b0
import  -/  base-4.9.1.0:Prelude 74b3e204395920329f6de9d97206abe9
import  -/  ghc-prim-0.5.0.0:GHC.Classes 16d48e012d23eaef9bca91ccdd572c02
import  -/  Sudoku.Board 4ebd9ce72fba7d1200cd249e35d9a5c5
  exports: 0af7e44c421fb125ffc82345651781f6
  Board 5d638fd64ab7761398eda74e33c31d8b
  Board 43bd58eab58ea2c9a991cc5975f42ee2
  Box 7a61135c326f6d3e35d3859a84dd7627
  Column a1e1b51592eb7195c004951e9310b560
  Constraint 3fdbcd988a245877e309dd8f87495ca5
  Row cffaec400eb4e72782f297cfb6daacc8
  Sum 314b8ef7fa3161ab9e4771b8dc34c08a
  Unique 9a9dc922e5bce95ed0209b7dd2f8f938
  addConstraints d6d1bfb0180c640d98d3f7cb5d6ef70f
  boxSize 87c5f654dfda4a06d980287efde34381
  chunk 991f0698a4bd80cb48647da172203a4e
  cs 677ee2428c213ccefb9032bb8ff7b2af
  defaultConstraints c685c34a6a8bd3923ddb10169be53067
  emptyBoard a912ee1b6acd185d5d839edab970ecd0
  fromList 748f22cfb9ade23e595a0bbf6fdd27c7
  mat 0f7f5b3167b7ab6b0b22a161699db89a
  noFull 25e269dea11f8f0e34ebc71c305bab48
  updateEntry 70d94e065a513fb0002bcab816a8fe01
import  -/  Sudoku.Entry 11cbc9d65f681efba5157b72ef244a0f
  exports: fb6ea1eab072e0d4518f55a8e342bb23
  Empty f5614a831015ca0b87e351a0c52f11e3
  Entry 6089eb51599d3a84243e1c09c3c0188b
  Full 0f7826996cab01aa97e15dcc6295260c
  isEmpty e300e17572d4ee24d3d481fa66a3abcf
  isFull 5734b1901f5c3a0fa4c29853eaba7d35
import  -/  matrix-0.3.5.0@matrix-0.3.5.0-eFZR6K8Lax4OrNeuTQF4y:Data.Matrix 2de8b1528e8778fd4bf7452f8e58a0dc
cfe064ab9d925abbc9efdce61e159240
  $s$fEq(,) :: GHC.Classes.Eq (GHC.Types.Int, GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Types.Int, GHC.Types.Int)
                  (GHC.Classes.$fEq(,)_$c==
                     @ GHC.Types.Int
                     @ GHC.Types.Int
                     GHC.Classes.$fEqInt
                     GHC.Classes.$fEqInt)
                  (GHC.Classes.$fEq(,)_$c/=
                     @ GHC.Types.Int
                     @ GHC.Types.Int
                     GHC.Classes.$fEqInt
                     GHC.Classes.$fEqInt) -}
b69296df5b9163e3bf334b591985f766
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Sudoku.$trModule2
                   Sudoku.$trModule1) -}
d0eb5ff3ecc3811acbcaa8ab0151f64d
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Sudoku"#) -}
0d63fdde2ea4a6cadcf880950a0262bc
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
6f5ab284aab6d0913bc6724797a12885
  $wemptyEntries ::
    GHC.Prim.Int#
    -> Data.Matrix.Matrix Sudoku.Entry.Entry
    -> [(GHC.Types.Int, GHC.Types.Int)]
  {- Arity: 2, Strictness: <S,U><L,U(U,U,U,U,U,U(U,A,U))>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: Data.Matrix.Matrix Sudoku.Entry.Entry) ->
                 let {
                   y :: GHC.Prim.Int# = GHC.Prim.*# ww ww
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># 1# y) of wild {
                   GHC.Types.False
                   -> let {
                        lvl50 :: [GHC.Types.Int] = GHC.Enum.eftInt 1# y
                      } in
                      letrec {
                        go :: GHC.Prim.Int# -> [(GHC.Types.Int, GHC.Types.Int)]
                          {- Arity: 1, Strictness: <S,U> -}
                        = \ (x :: GHC.Prim.Int#) ->
                          let {
                            ds :: GHC.Types.Int {- Strictness: m -} = GHC.Types.I# x
                          } in
                          let {
                            z :: [(GHC.Types.Int, GHC.Types.Int)]
                            = case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.==# x y) of wild1 {
                                GHC.Types.False -> go (GHC.Prim.+# x 1#)
                                GHC.Types.True -> GHC.Types.[] @ (GHC.Types.Int, GHC.Types.Int) }
                          } in
                          let {
                            lvl51 :: GHC.Types.Bool
                            = GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# x 1#)
                          } in
                          letrec {
                            go1 :: [GHC.Types.Int] -> [(GHC.Types.Int, GHC.Types.Int)]
                              {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [GHC.Types.Int]) ->
                              case ds1 of wild1 {
                                [] -> z
                                : y1 ys
                                -> case ww1 of ww2 { Data.Matrix.M ww3 ww4 ww5 ww6 ww7 ww8 ->
                                   case GHC.Prim.tagToEnum#
                                          @ GHC.Types.Bool
                                          (GHC.Prim.># x ww3) of wild2 {
                                     GHC.Types.False
                                     -> case y1 of wild3 { GHC.Types.I# x1 ->
                                        case GHC.Prim.tagToEnum#
                                               @ GHC.Types.Bool
                                               (GHC.Prim.># x1 ww4) of wild4 {
                                          GHC.Types.False
                                          -> case lvl51 of wild5 {
                                               GHC.Types.False
                                               -> case GHC.Prim.tagToEnum#
                                                         @ GHC.Types.Bool
                                                         (GHC.Prim.<# x1 1#) of wild6 {
                                                    GHC.Types.False
                                                    -> case ww8 of wild7 { Data.Vector.Vector dt dt1 dt2 ->
                                                       case GHC.Prim.indexArray#
                                                              @ Sudoku.Entry.Entry
                                                              dt2
                                                              (GHC.Prim.+#
                                                                 dt
                                                                 (GHC.Prim.-#
                                                                    (GHC.Prim.+#
                                                                       (GHC.Prim.*#
                                                                          (GHC.Prim.-#
                                                                             (GHC.Prim.+# x ww5)
                                                                             1#)
                                                                          ww7)
                                                                       (GHC.Prim.+# x1 ww6))
                                                                    1#)) of ds2 { Unit# ipv ->
                                                       case ipv of wild8 {
                                                         Sudoku.Entry.Full ipv1 -> go1 ys
                                                         Sudoku.Entry.Empty
                                                         -> GHC.Types.:
                                                              @ (GHC.Types.Int, GHC.Types.Int)
                                                              (ds, wild3)
                                                              (go1 ys) } } }
                                                    GHC.Types.True
                                                    -> case Sudoku.emptyEntries1 wild3 x ww4 ww3
                                                       ret_ty [(GHC.Types.Int, GHC.Types.Int)]
                                                       of {} }
                                               GHC.Types.True
                                               -> case Sudoku.emptyEntries1 wild3 x ww4 ww3
                                                  ret_ty [(GHC.Types.Int, GHC.Types.Int)]
                                                  of {} }
                                          GHC.Types.True
                                          -> case Sudoku.emptyEntries1 wild3 x ww4 ww3
                                             ret_ty [(GHC.Types.Int, GHC.Types.Int)]
                                             of {} } }
                                     GHC.Types.True
                                     -> case Sudoku.emptyEntries1 y1 x ww4 ww3
                                        ret_ty [(GHC.Types.Int, GHC.Types.Int)]
                                        of {} } } }
                          } in
                          go1 lvl50
                      } in
                      go 1#
                   GHC.Types.True
                   -> GHC.Types.[] @ (GHC.Types.Int, GHC.Types.Int) }) -}
c5cd371b737f21f6807b16321af57c5f
  $wvalidEntries ::
    Sudoku.Board.Board
    -> GHC.Prim.Int# -> GHC.Types.Int -> [Sudoku.Entry.Entry]
  {- Arity: 3,
     Strictness: <L,1*U(A,U(U),U(U,U,U,U,U,U(U,U,U)),1*U)><S,U><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ (w :: Sudoku.Board.Board)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: GHC.Types.Int) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww 1#) of wild {
                   GHC.Types.False
                   -> case w1 of wild1 { GHC.Types.I# x ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<# x 1#) of wild2 {
                        GHC.Types.False
                        -> case w of wild3 { Sudoku.Board.Board ds1 ds2 ds3 ds4 ->
                           case ds2 of wild4 { GHC.Types.I# x1 ->
                           let {
                             y :: GHC.Prim.Int# = GHC.Prim.*# x1 x1
                           } in
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.># ww y) of wild5 {
                             GHC.Types.False
                             -> case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.># x y) of wild6 {
                                  GHC.Types.False
                                  -> case ds3 of ww2 { Data.Matrix.M ww3 ww4 ww5 ww6 ww7 ww8 ->
                                     case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.># ww ww3) of wild7 {
                                       GHC.Types.False
                                       -> case GHC.Prim.tagToEnum#
                                                 @ GHC.Types.Bool
                                                 (GHC.Prim.># x ww4) of wild8 {
                                            GHC.Types.False
                                            -> case ww8 of wild9 { Data.Vector.Vector dt dt1 dt2 ->
                                               case GHC.Prim.indexArray#
                                                      @ Sudoku.Entry.Entry
                                                      dt2
                                                      (GHC.Prim.+#
                                                         dt
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.+#
                                                               (GHC.Prim.*#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.+# ww ww5)
                                                                     1#)
                                                                  ww7)
                                                               (GHC.Prim.+# x ww6))
                                                            1#)) of ds7 { Unit# ipv ->
                                               case ipv of wild10 {
                                                 Sudoku.Entry.Full ds8
                                                 -> GHC.Types.:
                                                      @ Sudoku.Entry.Entry
                                                      wild10
                                                      (GHC.Types.[] @ Sudoku.Entry.Entry)
                                                 Sudoku.Entry.Empty
                                                 -> let {
                                                      wild11 :: GHC.Types.Int = GHC.Types.I# ww
                                                    } in
                                                    letrec {
                                                      go :: [Sudoku.Board.Constraint]
                                                            -> [[Sudoku.Entry.Entry]]
                                                        {- Arity: 1, Strictness: <S,1*U> -}
                                                      = \ (ds :: [Sudoku.Board.Constraint]) ->
                                                        case ds of wild12 {
                                                          [] -> GHC.Types.[] @ [Sudoku.Entry.Entry]
                                                          : y1 ys
                                                          -> case Sudoku.inConstraint
                                                                    wild11
                                                                    wild1
                                                                    y1 of wild13 {
                                                               GHC.Types.False -> go ys
                                                               GHC.Types.True
                                                               -> GHC.Types.:
                                                                    @ [Sudoku.Entry.Entry]
                                                                    (Sudoku.possibleValues wild3 y1)
                                                                    (go ys) } }
                                                    } in
                                                    case go ds4 of wild12 {
                                                      [] -> GHC.Types.[] @ Sudoku.Entry.Entry
                                                      : ipv1 ipv2
                                                      -> Sudoku.validEntries_go wild12 } } } }
                                            GHC.Types.True
                                            -> case Sudoku.validEntries1 x ww ww4 ww3
                                               ret_ty [Sudoku.Entry.Entry]
                                               of {} }
                                       GHC.Types.True
                                       -> case Sudoku.validEntries1 x ww ww4 ww3
                                          ret_ty [Sudoku.Entry.Entry]
                                          of {} } }
                                  GHC.Types.True -> GHC.Types.[] @ Sudoku.Entry.Entry }
                             GHC.Types.True -> GHC.Types.[] @ Sudoku.Entry.Entry } } }
                        GHC.Types.True -> GHC.Types.[] @ Sudoku.Entry.Entry } }
                   GHC.Types.True -> GHC.Types.[] @ Sudoku.Entry.Entry }) -}
0e790962fa4ee71ed8bc5384198d4f6f
  complete :: Sudoku.Board.Board -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(S)S(S)LL),1*U(1*U(U),1*U(U),A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (board :: Sudoku.Board.Board) ->
                 case board of wild { Sudoku.Board.Board ds1 ds2 ds3 ds4 ->
                 case ds2 of wild1 { GHC.Types.I# x ->
                 case ds1 of wild2 { GHC.Types.I# x1 ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.==#
                      x1
                      (GHC.Prim.*# (GHC.Prim.*# (GHC.Prim.*# x x) x) x)) } } }) -}
1c5e42f05efeb2270adc22c39f8cada8
  emptyEntries ::
    Sudoku.Board.Board -> [(GHC.Types.Int, GHC.Types.Int)]
  {- Arity: 1,
     Strictness: <S(LS(S)LL),1*U(A,1*U(U),U(U,U,U,U,U,U(U,A,U)),A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Sudoku.Board.Board) ->
                 case w of ww { Sudoku.Board.Board ww1 ww2 ww3 ww4 ->
                 case ww2 of ww5 { GHC.Types.I# ww6 ->
                 Sudoku.$wemptyEntries ww6 ww3 } }) -}
ab392851c15ec885ace8063f6acd8acc
  emptyEntries1 ::
    GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Sudoku.Entry.Entry
  {- Arity: 4, Strictness: <L,U><L,U><L,U><L,U>x -}
749be5f1faec479431da1ef4737a5ae4
  inConstraint ::
    GHC.Types.Int
    -> GHC.Types.Int -> Sudoku.Board.Constraint -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(U)><L,U(U)><S,1*U>,
     Unfolding: (\ (row :: GHC.Types.Int)
                   (col :: GHC.Types.Int)
                   (c :: Sudoku.Board.Constraint) ->
                 case c of wild {
                   Sudoku.Board.Unique cs
                   -> GHC.List.elem
                        @ (GHC.Types.Int, GHC.Types.Int)
                        Sudoku.$s$fEq(,)
                        (row, col)
                        cs
                   Sudoku.Board.Sum ds cs
                   -> GHC.List.elem
                        @ (GHC.Types.Int, GHC.Types.Int)
                        Sudoku.$s$fEq(,)
                        (row, col)
                        cs
                   Sudoku.Board.Column i -> GHC.Classes.eqInt col i
                   Sudoku.Board.Row i -> GHC.Classes.eqInt row i
                   Sudoku.Board.Box ds
                   -> case ds of wild1 { (,,,) sR eR sC eC ->
                      case sR of wild2 { GHC.Types.I# x ->
                      case row of wild3 { GHC.Types.I# y ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# x y) of wild4 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case eR of wild5 { GHC.Types.I# y1 ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<=# y y1) of wild6 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case sC of wild7 { GHC.Types.I# x1 ->
                                case col of wild8 { GHC.Types.I# y2 ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.<=# x1 y2) of wild9 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> case eC of wild10 { GHC.Types.I# y3 ->
                                     GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.<=# y2 y3) } } } } } } } } } } }) -}
8b4d6f201c128639315abba76d6ffd4c
  intersectAll :: GHC.Classes.Eq a => [[a]] -> [a]
  {- Arity: 2, Strictness: <L,U(C(C(U)),A)><S,1*U>,
     Unfolding: (\ @ a ($dEq :: GHC.Classes.Eq a) (ds :: [[a]]) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ a
                   : ipv ipv1
                   -> let {
                        lvl50 :: a -> a -> GHC.Types.Bool = GHC.Classes.== @ a $dEq
                      } in
                      letrec {
                        go :: [[a]] -> [a] {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds1 :: [[a]]) ->
                          case ds1 of wild1 {
                            [] -> Sudoku.intersectAll1 @ a
                            : x ds2
                            -> case ds2 of wild2 {
                                 [] -> x
                                 : ipv2 ipv3 -> Data.OldList.intersectBy @ a lvl50 x (go wild2) } }
                      } in
                      go wild }) -}
770331eb9f82833d295e7649b490469c
  intersectAll1 :: [a]
  {- Strictness: x -}
ca9ed3dc17167e9b4e45ab71e7592740
  possibleValues ::
    Sudoku.Board.Board
    -> Sudoku.Board.Constraint -> [Sudoku.Entry.Entry]
  {- Arity: 2,
     Strictness: <L,U(A,1*U(U),1*U(U,U,U,U,U,U(U,U,U)),A)><S,1*U> -}
ae6a0168d01d2de177f845f62750adc1
  validEntries ::
    Sudoku.Board.Board
    -> GHC.Types.Int -> GHC.Types.Int -> [Sudoku.Entry.Entry]
  {- Arity: 3,
     Strictness: <L,1*U(A,U(U),U(U,U,U,U,U,U(U,U,U)),1*U)><S(S),1*U(U)><L,1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Sudoku.Board.Board)
                   (w1 :: GHC.Types.Int)
                   (w2 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Sudoku.$wvalidEntries w ww1 w2 }) -}
99f31518ae524db969b3d130308f95ab
  validEntries1 ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Sudoku.Entry.Entry
  {- Arity: 4, Strictness: <L,U><L,U><L,U><L,U>x -}
2fd0e7ff791e156ed5d191ca74d38ddf
  validEntries_go :: [[Sudoku.Entry.Entry]] -> [Sudoku.Entry.Entry]
  {- Arity: 1, Strictness: <S,1*U> -}
"SPEC/Sudoku $fEq(,) @ Int @ Int" [ALWAYS] forall ($dEq1 :: GHC.Classes.Eq
                                                              GHC.Types.Int)
                                                  ($dEq :: GHC.Classes.Eq GHC.Types.Int)
  GHC.Classes.$fEq(,) @ GHC.Types.Int @ GHC.Types.Int $dEq $dEq1
  = Sudoku.$s$fEq(,)
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

